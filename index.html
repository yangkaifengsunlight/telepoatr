<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AI智能提词器</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      /* 1. 确保 HTML 和 BODY 占据全部视口高度 */
      html,
      body {
        height: 100%;
        margin: 0;
      }

      /* 2. BODY 使用 Flexbox 垂直布局 */
      body {
        font-family: "Inter", sans-serif;
        background-color: #1f2937; /* Gray-800 */
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      /* 3. 容器设置：占据全部高度 */
      .main-container {
        flex-grow: 1; /* 占据 Body 剩余高度 */
        display: flex;
        flex-direction: column;
        padding: 1rem;
        overflow: hidden;
        min-height: 0; /* 关键修复 1: 确保包含滚动内容的 Flex 容器不会崩溃 */
      }

      /* 4. 提词器显示区域：占据所有剩余空间 */
      #teleprompter-display {
        position: relative;
        flex-grow: 1; /* 占据 main-container 剩余高度 */
        overflow: hidden;
        min-height: 0; /* 关键修复 2: 确保滚动区域的父元素正确计算其高度 */
      }

      /* 脚本内容容器：内部负责滚动 */
      #script-content-wrapper {
        width: 100%;
        max-width: 900px;
        height: 100%; /* 100% of #teleprompter-display's calculated height */
        overflow-y: scroll;
        scroll-behavior: smooth;
        padding-top: 50vh;
        padding-bottom: 50vh;
        transition: transform 0.3s ease-out;
        -webkit-overflow-scrolling: touch;
        margin-left: auto;
        margin-right: auto;
      }

      /* === 全屏模式样式保持不变，但更健壮 === */
      .is-fullscreen {
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        right: 0 !important;
        bottom: 0 !important;
        width: 100vw !important;
        height: 100vh !important;
        z-index: 50;
        border-radius: 0 !important;
        padding: 0 !important;
      }

      .is-fullscreen #script-content-wrapper {
        height: 100vh !important;
      }

      /* 定位居中线 */
      #center-line {
        position: absolute;
        top: 50%;
        left: 0;
        right: 0;
        border-top: 2px dashed #fcd34d; /* Amber-300 */
        z-index: 10;
      }

      .script-segment {
        transition: color 0.3s, transform 0.3s, opacity 0.3s;
        text-align: center;
      }
      .active-segment {
        color: #ffeb3b !important; /* Brighter Yellow for better contrast */
        transform: scale(1.05);
        font-weight: 700 !important;
      }
      .recognition-hint {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 50;
        padding: 0.5rem 1rem;
        background: rgba(251, 191, 36, 0.95);
        color: #1f2937;
        border-radius: 9999px;
        font-weight: 600;
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.2);
        opacity: 0;
        transition: opacity 0.5s ease;
      }
      .recognition-hint.visible {
        opacity: 1;
      }
    </style>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              primary: "#fcd34d",
              secondary: "#374151",
            },
          },
        },
      };
    </script>
  </head>
  <body class="bg-gray-900 text-gray-100">
    <!-- 主容器：使用 flex-grow 占据 BODY 的全部高度 -->
    <div class="main-container mx-auto max-w-7xl">
      <!-- 标题包裹层，用于全屏时隐藏 -->
      <div id="header-wrapper" class="flex-shrink-0">
        <h1 class="text-3xl font-bold text-center mb-4 text-primary">
          AI智能提词器 🎙️
        </h1>
      </div>

      <!-- 状态和提示信息 (保持在主界面可见) -->
      <div
        id="status-message"
        class="text-center p-2 rounded-lg font-medium h-6 mb-2 text-red-400 flex-shrink-0"
      >
        <!-- 状态/错误信息 -->
      </div>

      <!-- 提词器显示区 (Flex-Grow: 1 占据剩余空间) -->
      <div
        id="teleprompter-display"
        class="relative bg-gray-900 rounded-xl shadow-2xl border border-gray-700"
      >
        <div id="center-line"></div>
        <!-- 脚本内容容器：负责滚动 (文本颜色为白色) -->
        <div id="script-content-wrapper" class="text-white">
          <!-- 脚本内容将在此处插入 -->
        </div>
        <div id="recognition-hint" class="recognition-hint">
          正在听... 请说当前段落
        </div>

        <!-- 全屏模式下的中心控制图标 (Play/Pause) -->
        <div
          id="fs-overlay-controls"
          class="hidden absolute inset-0 z-50 justify-center items-center pointer-events-none"
        >
          <div
            class="p-4 rounded-full bg-gray-900/60 text-white shadow-2xl transition-opacity duration-300"
          >
            <!-- Pause Icon -->
            <svg
              id="fs-pause-icon"
              class="w-16 h-16 sm:w-20 sm:h-20"
              fill="currentColor"
              viewBox="0 0 24 24"
            >
              <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z" />
            </svg>
            <!-- Play Icon -->
            <svg
              id="fs-play-icon"
              class="w-16 h-16 sm:w-20 sm:h-20 hidden"
              fill="currentColor"
              viewBox="0 0 24 24"
            >
              <path d="M8 5v14l11-7z" />
            </svg>
          </div>
        </div>

        <!-- 推出全屏按钮 (固定在右上角) -->
        <button
          id="exit-fs-btn"
          class="hidden absolute top-4 right-4 z-50 p-2 rounded-full bg-gray-700/70 text-white hover:bg-gray-600/90 transition-opacity pointer-events-auto shadow-lg"
        >
          <!-- X Icon -->
          <svg
            class="w-6 h-6"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M6 18L18 6M6 6l12 12"
            ></path>
          </svg>
        </button>
      </div>

      <!-- 快速操作栏 (Flex-Shrink: 0 不会缩小) -->
      <div
        id="primary-controls"
        class="flex-shrink-0 mt-4 bg-gray-800 p-4 rounded-xl shadow-lg"
      >
        <div class="flex flex-wrap justify-center items-center gap-4">
          <!-- 模式切换按钮 -->
          <button
            id="mode-toggle-btn"
            class="flex-1 min-w-[120px] px-4 py-2 rounded-lg font-semibold transition duration-200 bg-yellow-600 hover:bg-yellow-500 text-gray-900 shadow-md"
          >
            切换到 语音模式
          </button>

          <!-- 启动/停止按钮 -->
          <button
            id="start-stop-btn"
            class="flex-1 min-w-[120px] px-4 py-2 rounded-lg font-semibold transition duration-200 bg-green-600 hover:bg-green-500 text-white shadow-md"
            disabled
          >
            启动滚动
          </button>

          <!-- 重置按钮 -->
          <button
            id="reset-btn"
            class="flex-1 min-w-[120px] px-4 py-2 rounded-lg font-semibold transition duration-200 bg-red-600 hover:bg-red-500 text-white shadow-md"
          >
            重置位置
          </button>

          <!-- 全屏按钮 -->
          <button
            id="fullscreen-btn"
            class="flex-1 min-w-[120px] px-4 py-2 rounded-lg font-semibold transition duration-200 bg-blue-600 hover:bg-blue-500 text-white shadow-md"
          >
            全屏显示
          </button>

          <!-- 镜像功能按钮 -->
          <button
            id="mirror-toggle-btn"
            class="flex-1 min-w-[120px] px-4 py-2 rounded-lg font-semibold transition duration-200 bg-gray-600 hover:bg-gray-500 text-white shadow-md"
          >
            开启镜像
          </button>

          <!-- NEW Settings Button to open modal -->
          <button
            id="settings-button"
            class="flex-1 min-w-[120px] px-4 py-2 rounded-lg font-semibold transition duration-200 bg-gray-700 hover:bg-gray-600 text-white shadow-md"
          >
            设置 & 脚本
          </button>
        </div>
      </div>
    </div>
    <!-- END OF MAIN CONTAINER -->

    <!-- === 设置弹窗 (Modal) === -->
    <div
      id="settings-modal"
      class="hidden fixed inset-0 z-[100] bg-black bg-opacity-80 flex justify-center items-center p-4"
      aria-modal="true"
      role="dialog"
    >
      <div
        id="control-panel"
        class="bg-gray-900 border border-gray-700 p-6 rounded-xl shadow-2xl w-full max-w-4xl max-h-[90vh] overflow-y-auto transform transition-all duration-300"
      >
        <div
          class="flex justify-between items-center mb-6 border-b border-gray-700 pb-3"
        >
          <h2 class="text-2xl font-bold text-primary">提词器设置与脚本</h2>
          <button
            id="close-modal-btn"
            class="text-gray-400 hover:text-white transition"
          >
            <svg
              class="w-8 h-8"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M6 18L18 6M6 6l12 12"
              ></path>
            </svg>
          </button>
        </div>

        <!-- Control Row 1: 滚动速度、字体大小、文本边距、段落间距控制 -->
        <div class="flex flex-wrap justify-start items-center gap-6 mt-4">
          <!-- 滚动速度控制 -->
          <div class="w-full sm:w-1/2 lg:w-[23%]">
            <label
              for="scroll-speed"
              class="block text-sm font-medium text-gray-300"
              >滚动速度 (<span id="speed-value">2</span>)</label
            >
            <input
              type="range"
              id="scroll-speed"
              min="0.5"
              max="5"
              step="0.5"
              value="2"
              class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer"
            />
          </div>

          <!-- 字体大小控制 -->
          <div class="w-full sm:w-1/2 lg:w-[23%]">
            <label
              for="font-size"
              class="block text-sm font-medium text-gray-300"
              >字体大小 (<span id="font-value">48px</span>)</label
            >
            <input
              type="range"
              id="font-size"
              min="20"
              max="96"
              step="4"
              value="48"
              class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer"
            />
          </div>

          <!-- 文本边距控制 (Horizontal Padding) -->
          <div class="w-full sm:w-1/2 lg:w-[23%]">
            <label
              for="text-padding"
              class="block text-sm font-medium text-gray-300"
              >文本边距(左右) (<span id="padding-value">20px</span>)</label
            >
            <input
              type="range"
              id="text-padding"
              min="0"
              max="150"
              step="5"
              value="20"
              class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer"
            />
          </div>

          <!-- 段落间距控制 (Vertical Margin) -->
          <div class="w-full sm:w-1/2 lg:w-[23%]">
            <label
              for="paragraph-spacing"
              class="block text-sm font-medium text-gray-300"
              >段落间距(垂直) (<span id="paragraph-value">20px</span>)</label
            >
            <input
              type="range"
              id="paragraph-spacing"
              min="5"
              max="100"
              step="5"
              value="20"
              class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer"
            />
          </div>
        </div>

        <!-- Control Row 2: 行高控制 -->
        <div
          class="flex flex-wrap justify-start items-center gap-6 mt-6 pt-4 border-t border-gray-700"
        >
          <!-- 行高控制 (Line Height) -->
          <div class="w-full sm:w-1/2 lg:w-[23%]">
            <label
              for="line-height-control"
              class="block text-sm font-medium text-gray-300"
              >行高 (行内间距) (<span id="line-height-value">1.5</span>)</label
            >
            <input
              type="range"
              id="line-height-control"
              min="1.0"
              max="2.5"
              step="0.1"
              value="1.5"
              class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer"
            />
          </div>
        </div>

        <!-- 文本输入区, 独立一行 -->
        <div class="w-full mt-6">
          <label
            for="script-input"
            class="block text-sm font-medium text-gray-300"
            >演讲稿内容 (请按换行键分隔行)</label
          >
          <!-- 适配横屏和桌面：默认高 6rem (h-24)，中等屏幕以上高 9rem (md:h-36) -->
          <textarea
            id="script-input"
            class="w-full h-36 p-2 mt-1 rounded-lg bg-gray-700 text-gray-200 focus:ring-primary focus:border-primary border border-gray-600"
          >
各位观众大家好，欢迎来到今天的分享会。

信息时代，我们常被数字世界的混乱所困扰。
你是不是也常被电脑、手机、网盘里的文件搞得焦头烂额？
明明保存过的东西，偏偏急用时翻遍全网都找不到？

别急，今天我要给你分享一个超简单的方法——PARA！
只需要4个文件夹，就能让你的数字生活瞬间变清爽，找东西再也不抓狂。

项目（Projects）放你眼下正在忙的事。
领域（Areas）放你生活中需要持续关注的大块领域。
资源（Resources）放你感兴趣或正在学习的知识库。
归档（Archives）放过去完成或暂时用不上的东西。

对，就是这么简单！这四个文件夹，涵盖了你数字生活的所有东西。
工作任务、个人兴趣，PARA都能帮你分得清清楚楚。
我自己试了以后，真的有种“救命啊终于找到组织神器”的感觉！
试一次，你就知道有多爽！
感谢大家的收听，期待与你下期再见！peace～
                </textarea
          >
        </div>
      </div>
    </div>

    <script>
      // 全局变量
      let scrollAnimFrameId = null;
      let isScrolling = false;
      let isVoiceMode = false;
      let isMirrored = false;
      let isFullscreen = false;
      let recognition = null;
      let scriptSegments = [];
      let currentSegmentIndex = 0;

      // DOM 元素
      const headerWrapper = document.getElementById("header-wrapper");
      const display = document.getElementById("script-content-wrapper");
      const input = document.getElementById("script-input");
      const startStopBtn = document.getElementById("start-stop-btn");
      const resetBtn = document.getElementById("reset-btn");
      const speedInput = document.getElementById("scroll-speed");
      const speedValue = document.getElementById("speed-value");
      const fontInput = document.getElementById("font-size");
      const fontValue = document.getElementById("font-value");
      const paddingInput = document.getElementById("text-padding");
      const paddingValue = document.getElementById("padding-value");
      const paragraphInput = document.getElementById("paragraph-spacing");
      const paragraphValue = document.getElementById("paragraph-value");
      const lineHeightInput = document.getElementById("line-height-control");
      const lineHeightValue = document.getElementById("line-height-value");
      const mirrorToggleBtn = document.getElementById("mirror-toggle-btn");
      const fullscreenBtn = document.getElementById("fullscreen-btn");
      const fsOverlayControls = document.getElementById("fs-overlay-controls");
      const fsPauseIcon = document.getElementById("fs-pause-icon");
      const fsPlayIcon = document.getElementById("fs-play-icon");
      const exitFsBtn = document.getElementById("exit-fs-btn");

      // MODAL ELEMENTS
      const settingsButton = document.getElementById("settings-button");
      const settingsModal = document.getElementById("settings-modal");
      const closeModalBtn = document.getElementById("close-modal-btn");

      const statusMessage = document.getElementById("status-message");
      const modeToggleBtn = document.getElementById("mode-toggle-btn");
      const recognitionHint = document.getElementById("recognition-hint");

      // --- 辅助函数 ---

      /**
       * 渲染脚本到提词器显示区 (现在是按行分割)
       */
      function renderScript() {
        const lines = input.value.split("\n");
        scriptSegments = lines;

        display.innerHTML = "";
        const currentParagraphSpacing = paragraphInput.value;
        const currentLineHeight = lineHeightInput.value;
        const lineVPadding = "8px";

        scriptSegments.forEach((segment, index) => {
          const div = document.createElement("div");
          const content = segment.trim() === "" ? "&nbsp;" : segment.trim();

          // 注意：这里 class 里的 text-white 是从父级继承的，确保可见
          div.className =
            "script-segment text-2xl md:text-3xl lg:text-4xl font-semibold opacity-70 transition-all duration-300";
          div.id = `segment-${index}`;
          div.innerHTML = content;
          div.style.fontSize = `${fontInput.value}px`;
          div.style.lineHeight = currentLineHeight;

          if (segment.trim() === "") {
            div.style.marginBottom = `${currentParagraphSpacing}px`;
            div.style.height = "0";
            div.style.padding = "0";
          } else {
            div.style.paddingTop = lineVPadding;
            div.style.paddingBottom = lineVPadding;
            div.style.marginBottom = "0px";
          }

          if (isMirrored) {
            div.style.transform = "scaleX(-1)";
          }

          display.appendChild(div);
        });

        resetPosition();
        updateActiveSegment();
        updateStartButtonState();
      }

      /**
       * 检查内容是否可滚动并更新启动按钮状态
       */
      function updateStartButtonState() {
        const hasContent =
          scriptSegments.length > 0 &&
          scriptSegments.some((s) => s.trim() !== "");

        if (!hasContent) {
          startStopBtn.disabled = true;
          statusMessage.innerText = "脚本内容为空，请在设置中输入脚本。";
          return;
        }

        // 延迟检查，确保DOM布局完成且scrollHeight计算准确
        setTimeout(() => {
          // 检查内容是否溢出容器 (这是移动端滚动失败的关键检查点)
          const isScrollable = display.scrollHeight > display.clientHeight + 10; // 增加10px缓冲
          startStopBtn.disabled = !isScrollable && !isVoiceMode;

          if (!isScrollable && !isVoiceMode) {
            statusMessage.innerText = "⚠️ 脚本内容太短，无法启动滚动。";
          } else {
            // 只有在非语音模式下且无滚动问题时才清空状态，以免覆盖语音提示
            if (!isVoiceMode) {
              statusMessage.innerText = "";
            }
          }
        }, 100); // 100ms 延迟确保布局在移动端稳定
      }

      /**
       * 更新当前活动的段落/行样式
       */
      function updateActiveSegment() {
        document.querySelectorAll(".script-segment").forEach((el, index) => {
          el.classList.remove("active-segment", "opacity-100");

          if (index === currentSegmentIndex) {
            el.classList.add("active-segment", "opacity-100");
            el.classList.remove("opacity-70", "opacity-30");
          } else if (index < currentSegmentIndex) {
            el.classList.add("opacity-30");
            el.classList.remove("opacity-70");
          } else {
            el.classList.add("opacity-70");
            el.classList.remove("opacity-30");
          }
        });
      }

      /**
       * 根据当前滚动位置更新活动段落
       */
      function updateSegmentByScrollPosition() {
        // 只有在手动滚动或静止时，才根据位置更新活动段落
        if (isScrolling || isVoiceMode) return;

        const segments = document.querySelectorAll(".script-segment");
        if (segments.length === 0) return;

        const scrollWrapperRect = display.getBoundingClientRect();
        const centerOffset =
          scrollWrapperRect.top + scrollWrapperRect.height / 2;

        let bestIndex = currentSegmentIndex;
        let minDistance = Infinity;

        segments.forEach((el, index) => {
          if (scriptSegments[index].trim() === "") return;

          const rect = el.getBoundingClientRect();
          const elCenter = rect.top + rect.height / 2;

          const distance = Math.abs(elCenter - centerOffset);

          if (distance < minDistance) {
            minDistance = distance;
            bestIndex = index;
          }
        });

        if (bestIndex !== currentSegmentIndex) {
          currentSegmentIndex = bestIndex;
          updateActiveSegment();
        }
      }

      /**
       * 平滑滚动到当前活动段落的中央
       */
      function smoothScrollToActiveSegment() {
        const activeSegment = document.getElementById(
          `segment-${currentSegmentIndex}`
        );
        if (activeSegment) {
          activeSegment.scrollIntoView({
            behavior: "smooth",
            block: "center",
          });
        }
      }

      /**
       * 检查 Web Speech API 兼容性
       */
      function checkSpeechApi() {
        if (
          !("webkitSpeechRecognition" in window) &&
          !("SpeechRecognition" in window)
        ) {
          statusMessage.innerText =
            "⚠️ 警告: 您的浏览器不支持 Web Speech API (语音识别)。智能语音模式将不可用。";
          modeToggleBtn.disabled = true;
          return false;
        }
        statusMessage.innerText = "";
        return true;
      }

      // --- Modal Logic ---

      function openSettingsModal() {
        settingsModal.classList.remove("hidden");
        document.body.classList.add("overflow-hidden");
        if (isScrolling) stopScroll();
        // 确保输入框聚焦，方便编辑
        setTimeout(() => input.focus(), 10);
      }

      function closeSettingsModal() {
        settingsModal.classList.add("hidden");
        document.body.classList.remove("overflow-hidden");
        // 确保内容更改后立即重新渲染脚本
        renderScript();
      }

      /**
       * 更新全屏模式下的暂停/播放图标
       */
      function updateFullscreenIcons() {
        if (!isFullscreen) return;
        if (isScrolling) {
          fsPauseIcon.classList.remove("hidden");
          fsPlayIcon.classList.add("hidden");
        } else {
          fsPauseIcon.classList.add("hidden");
          fsPlayIcon.classList.remove("hidden");
        }
      }

      // --- 核心模式逻辑：手动滚动 (使用 requestAnimationFrame) ---

      /**
       * 滚动循环 (使用 requestAnimationFrame)
       */
      function scrollLoop() {
        if (!isScrolling) return;

        const speed = parseFloat(speedInput.value);

        // 检查是否到达底部
        if (
          display.scrollTop + display.clientHeight >=
          display.scrollHeight - 5
        ) {
          stopScroll();
          return;
        }

        // 应用滚动
        display.scrollTop += speed;

        // 继续下一帧的循环
        scrollAnimFrameId = requestAnimationFrame(scrollLoop);
      }

      function startScroll() {
        if (isScrolling) return;

        // 1. 确保内容可滚动 (再次检查)
        if (display.scrollHeight <= display.clientHeight + 10) {
          statusMessage.innerText =
            "⚠️ 脚本内容太短，无法启动滚动。请在设置中添加更多文本。";
          stopScroll();
          return;
        }

        isScrolling = true;
        startStopBtn.innerText = "暂停滚动";
        startStopBtn.classList.remove("bg-green-600", "hover:bg-green-500");
        startStopBtn.classList.add("bg-orange-600", "hover:bg-orange-500");

        updateFullscreenIcons();

        // 2. 启动 requestAnimationFrame 循环
        scrollLoop();
      }

      function stopScroll() {
        if (!isScrolling) return;
        isScrolling = false;

        // 使用 cancelAnimationFrame 停止循环
        if (scrollAnimFrameId) {
          cancelAnimationFrame(scrollAnimFrameId);
          scrollAnimFrameId = null;
        }

        startStopBtn.innerText = "启动滚动";
        startStopBtn.classList.remove("bg-orange-600", "hover:bg-orange-500");
        startStopBtn.classList.add("bg-green-600", "hover:bg-green-500");

        updateFullscreenIcons();
      }

      // --- 核心模式逻辑：语音智能推进 (保持不变) ---

      function initSpeechRecognition() {
        if (!checkSpeechApi()) return;

        const SpeechRecognition =
          window.SpeechRecognition || window.webkitSpeechRecognition;
        recognition = new SpeechRecognition();
        recognition.continuous = false;
        recognition.interimResults = false;
        recognition.lang = "zh-CN";

        recognition.onstart = () => {
          recognitionHint.innerText = "🎙️ 正在听... 请说当前行";
          recognitionHint.classList.add("visible");
          statusMessage.innerText = "语音模式已启动，请开始朗读。";
        };

        recognition.onresult = (event) => {
          const transcript = event.results[0][0].transcript;
          console.log("识别结果:", transcript);
          checkAndAdvance(transcript);
        };

        recognition.onend = () => {
          recognitionHint.classList.remove("visible");
          if (isVoiceMode) {
            setTimeout(() => {
              if (isVoiceMode && currentSegmentIndex < scriptSegments.length) {
                try {
                  recognition.start();
                } catch (e) {
                  console.warn(
                    "Recognition already started, ignoring auto-restart."
                  );
                }
              } else if (currentSegmentIndex >= scriptSegments.length) {
                statusMessage.innerText = "✅ 脚本朗读完毕！";
              }
            }, 100);
          }
        };

        recognition.onerror = (event) => {
          console.error("语音识别错误:", event.error);
          statusMessage.innerText = `❌ 语音识别错误: ${event.error}. 请检查麦克风权限。`;
          recognitionHint.classList.remove("visible");
          if (isVoiceMode) {
            setTimeout(() => {
              if (isVoiceMode && currentSegmentIndex < scriptSegments.length) {
                try {
                  recognition.start();
                } catch (e) {}
              }
            }, 1000);
          }
        };
      }

      function startVoiceControl() {
        if (!recognition) initSpeechRecognition();
        isVoiceMode = true;
        startStopBtn.disabled = true;
        speedInput.disabled = true;
        fullscreenBtn.disabled = true;

        modeToggleBtn.innerText = "切换到 手动模式";
        modeToggleBtn.classList.remove("bg-yellow-600", "hover:bg-yellow-500");
        modeToggleBtn.classList.add("bg-purple-600", "hover:bg-purple-500");

        stopScroll();

        smoothScrollToActiveSegment();

        if (currentSegmentIndex < scriptSegments.length) {
          recognition.start();
        } else {
          statusMessage.innerText = "请点击重置按钮开始朗读。";
        }
      }

      function stopVoiceControl() {
        isVoiceMode = false;
        updateStartButtonState();
        speedInput.disabled = false;
        fullscreenBtn.disabled = false;

        modeToggleBtn.innerText = "切换到 语音模式";
        modeToggleBtn.classList.remove("bg-purple-600", "hover:bg-purple-500");
        modeToggleBtn.classList.add("bg-yellow-600", "hover:bg-yellow-500");

        recognitionHint.classList.remove("visible");
        statusMessage.innerText = "已切换回手动模式。";

        if (recognition) {
          recognition.stop();
        }
      }

      function checkAndAdvance(transcript) {
        if (!isVoiceMode || currentSegmentIndex >= scriptSegments.length)
          return;

        // 跳过空行
        while (
          currentSegmentIndex < scriptSegments.length &&
          scriptSegments[currentSegmentIndex].trim() === ""
        ) {
          currentSegmentIndex++;
        }
        if (currentSegmentIndex >= scriptSegments.length) {
          stopVoiceControl();
          statusMessage.innerText = "✅ 脚本朗读完毕！切换回手动模式。";
          return;
        }

        const currentLine = scriptSegments[currentSegmentIndex];
        const matchText = currentLine
          .replace(/[，。！？]/g, "")
          .trim()
          .slice(0, 15);

        const isMatch =
          transcript.includes(matchText.slice(0, 8)) ||
          (transcript.length > matchText.length * 0.5 &&
            transcript.includes(matchText.slice(0, 3)));

        if (isMatch) {
          console.log(
            `Matched line ${currentSegmentIndex + 1}: "${currentLine.slice(
              0,
              10
            )}..."`
          );
          currentSegmentIndex++;
          updateActiveSegment();
          smoothScrollToActiveSegment();

          if (currentSegmentIndex < scriptSegments.length) {
            // 确保下一个非空行被选中
            while (
              currentSegmentIndex < scriptSegments.length &&
              scriptSegments[currentSegmentIndex].trim() === ""
            ) {
              currentSegmentIndex++;
            }
            setTimeout(() => {
              if (isVoiceMode && currentSegmentIndex < scriptSegments.length)
                recognition.start();
            }, 500);
          } else {
            stopVoiceControl();
            statusMessage.innerText = "✅ 脚本朗读完毕！切换回手动模式。";
          }
        } else {
          // 没有匹配到，重新开始听
          setTimeout(() => {
            if (isVoiceMode) recognition.start();
          }, 500);
        }
      }

      // --- 其他事件处理 (保持不变) ---

      function toggleMirroring() {
        isMirrored = !isMirrored;
        const segments = document.querySelectorAll(".script-segment");

        if (isMirrored) {
          // Note: Applying mirror transform to the scrollable container
          document.getElementById("teleprompter-display").style.transform =
            "scaleX(-1)";
          segments.forEach((el) => {
            // Apply reverse mirror to content inside
            el.style.transform = "scaleX(-1)";
          });
          mirrorToggleBtn.innerText = "关闭镜像";
          mirrorToggleBtn.classList.remove("bg-gray-600", "hover:bg-gray-500");
          mirrorToggleBtn.classList.add("bg-blue-600", "hover:bg-blue-500");
        } else {
          document.getElementById("teleprompter-display").style.transform =
            "none";
          segments.forEach((el) => {
            el.style.transform = "none";
          });
          mirrorToggleBtn.innerText = "开启镜像";
          mirrorToggleBtn.classList.remove("bg-blue-600", "hover:bg-blue-500");
          mirrorToggleBtn.classList.add("bg-gray-600", "hover:bg-gray-500");
        }
      }

      function toggleFullscreen() {
        isFullscreen = !isFullscreen;
        const teleprompterDisplay = document.getElementById(
          "teleprompter-display"
        );

        if (isFullscreen) {
          if (isVoiceMode) stopVoiceControl();

          document.body.classList.add("overflow-hidden");
          headerWrapper.classList.add("hidden");
          document.getElementById("primary-controls").classList.add("hidden");
          statusMessage.classList.add("hidden");

          teleprompterDisplay.classList.add("is-fullscreen");

          fsOverlayControls.classList.remove("hidden");
          fsOverlayControls.classList.add("flex");
          exitFsBtn.classList.remove("hidden");

          fullscreenBtn.innerText = "退出全屏";

          updateFullscreenIcons();
          updateStartButtonState();
        } else {
          document.body.classList.remove("overflow-hidden");
          headerWrapper.classList.remove("hidden");
          document
            .getElementById("primary-controls")
            .classList.remove("hidden");
          statusMessage.classList.remove("hidden");

          teleprompterDisplay.classList.remove("is-fullscreen");

          fsOverlayControls.classList.add("hidden");
          fsOverlayControls.classList.remove("flex");
          exitFsBtn.classList.add("hidden");

          fullscreenBtn.innerText = "全屏显示";

          stopScroll();
          updateStartButtonState();
        }
      }

      function handleFullscreenClick() {
        if (isFullscreen && !isVoiceMode) {
          if (isScrolling) {
            stopScroll();
          } else {
            if (!startStopBtn.disabled) {
              startScroll();
            }
          }
        }
      }

      // --- 事件监听器 ---

      settingsButton.addEventListener("click", openSettingsModal);
      closeModalBtn.addEventListener("click", closeSettingsModal);
      settingsModal.addEventListener("click", (e) => {
        // 点击背景关闭 Modal
        if (e.target === settingsModal) {
          closeSettingsModal();
        }
      });

      modeToggleBtn.addEventListener("click", () => {
        if (isVoiceMode) {
          stopVoiceControl();
        } else {
          if (isFullscreen) {
            statusMessage.innerText =
              "⚠️ 语音模式下无法进入全屏滚动模式。请先退出全屏。";
            return;
          }
          startVoiceControl();
        }
      });

      startStopBtn.addEventListener("click", () => {
        if (isVoiceMode) return;
        isScrolling ? stopScroll() : startScroll();
      });

      mirrorToggleBtn.addEventListener("click", toggleMirroring);

      fullscreenBtn.addEventListener("click", () => {
        if (isVoiceMode) {
          statusMessage.innerText =
            "⚠️ 语音模式下无法进入全屏滚动模式。请先切换到手动模式。";
          return;
        }
        toggleFullscreen();
      });

      exitFsBtn.addEventListener("click", toggleFullscreen);

      document
        .getElementById("teleprompter-display")
        .addEventListener("click", handleFullscreenClick);

      display.addEventListener("scroll", updateSegmentByScrollPosition);

      document.addEventListener("keydown", (e) => {
        // 键盘操作：不在输入框内时响应
        if (
          input === document.activeElement ||
          settingsModal.classList.contains("hidden")
        )
          return;

        if (e.code === "Space" || e.key === "Enter") {
          e.preventDefault();
          if (isVoiceMode) return;

          if (isFullscreen && !startStopBtn.disabled) {
            handleFullscreenClick();
          } else if (!isFullscreen && !startStopBtn.disabled) {
            isScrolling ? stopScroll() : startScroll();
          }
        }

        if (!isVoiceMode) {
          const scrollStep = 40;
          let scrolled = false;

          if (e.key === "ArrowDown") {
            e.preventDefault();
            if (!isScrolling) {
              display.scrollTop += scrollStep;
              scrolled = true;
            }
          } else if (e.key === "ArrowUp") {
            e.preventDefault();
            if (!isScrolling) {
              display.scrollTop -= scrollStep;
              scrolled = true;
            }
          }

          if (scrolled) {
            setTimeout(updateSegmentByScrollPosition, 100);
          }
        }
      });

      resetBtn.addEventListener("click", () => {
        stopScroll();
        if (isVoiceMode) stopVoiceControl();
        resetPosition();
      });

      function resetPosition() {
        currentSegmentIndex = 0;
        display.scrollTop = 0;
        updateActiveSegment();
        if (isVoiceMode && scriptSegments.length > 0) {
          startVoiceControl();
        }
      }

      // 脚本输入和滑块更改事件：在弹窗中进行，但监听器保持不变
      input.addEventListener("input", () => {
        // 仅在关闭弹窗时调用 renderScript，以避免输入时频繁重绘
        // 但这里为了即时反馈，保留直接调用
        renderScript();
        stopScroll();
        if (isVoiceMode) stopVoiceControl();
      });

      speedInput.addEventListener("input", () => {
        speedValue.innerText = speedInput.value;
      });

      fontInput.addEventListener("input", () => {
        fontValue.innerText = `${fontInput.value}px`;
        document.querySelectorAll(".script-segment").forEach((el) => {
          el.style.fontSize = `${fontInput.value}px`;
          if (isMirrored) el.style.transform = "scaleX(-1)";
        });
        updateSegmentByScrollPosition();
      });

      paddingInput.addEventListener("input", () => {
        const value = `${paddingInput.value}px`;
        paddingValue.innerText = value;
        // Apply padding to the scrollable display element
        document.getElementById("teleprompter-display").style.paddingLeft =
          value;
        document.getElementById("teleprompter-display").style.paddingRight =
          value;
        updateSegmentByScrollPosition();
      });

      paragraphInput.addEventListener("input", () => {
        const value = `${paragraphInput.value}px`;
        paragraphValue.innerText = value;
        document.querySelectorAll(".script-segment").forEach((el, index) => {
          if (scriptSegments[index].trim() === "") {
            el.style.marginBottom = value;
          }
        });
        updateSegmentByScrollPosition();
      });

      lineHeightInput.addEventListener("input", () => {
        const value = lineHeightInput.value;
        lineHeightValue.innerText = value;
        document.querySelectorAll(".script-segment").forEach((el) => {
          el.style.lineHeight = value;
        });
        updateSegmentByScrollPosition();
      });

      window.addEventListener("resize", () => {
        setTimeout(updateStartButtonState, 200);
        if (isScrolling) {
          stopScroll();
        }
        smoothScrollToActiveSegment();
      });

      // --- 初始化 ---

      window.onload = function () {
        // 1. 设置初始内边距 (这里需要应用到外层容器)
        document.getElementById(
          "teleprompter-display"
        ).style.paddingLeft = `${paddingInput.value}px`;
        document.getElementById(
          "teleprompter-display"
        ).style.paddingRight = `${paddingInput.value}px`;

        // 2. 渲染脚本内容
        renderScript();

        // 3. 检查语音API并初始化
        checkSpeechApi();
        initSpeechRecognition();

        // 4. 重置滚动位置到顶部 (同时会触发 updateActiveSegment)
        resetPosition();

        // 5. 再次更新按钮状态
        updateStartButtonState();
      };
    </script>
  </body>
</html>
