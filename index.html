<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AI智能提词器</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      /* 强制使用深色背景，提高阅读对比度 */
      body {
        font-family: "Inter", sans-serif;
        background-color: #1f2937; /* Gray-800 */
      }
      /* 提词器内容区域，实现全屏居中阅读效果 */
      #teleprompter-display {
        position: relative;
        /* 默认高度：减去控制面板的高度，适用于大部分竖屏/桌面 */
        height: calc(100vh - 280px);
        overflow: hidden;
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 0 1rem;
      }

      /* === 响应式优化：针对横屏或小屏幕 === */
      @media (max-width: 1024px) and (orientation: landscape) {
        /* 在手机横屏模式下，控制面板在屏幕上占据的相对空间变小，
               因此提词器显示区可以占据更多的垂直高度 */
        #teleprompter-display {
          height: calc(100vh - 150px);
        }
        /* 隐藏主体内容的容器，避免在全屏时滚动 */
        .overflow-hidden {
          overflow: hidden;
        }
      }
      /* ================================== */

      /* === NEW: 全屏模式样式 === */
      .is-fullscreen {
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        right: 0 !important;
        bottom: 0 !important;
        width: 100vw !important;
        height: 100vh !important;
        z-index: 50; /* Needs to be high enough to cover everything */
        border-radius: 0 !important;
        border: none !important;
        padding: 0 !important; /* Remove container padding */
      }

      .is-fullscreen #script-content-wrapper {
        /* 确保内容在全屏时能使用全高 */
        height: 100vh !important;
      }

      /* 定制滚动条外观 */
      .scrolling-content::-webkit-scrollbar {
        width: 8px;
      }
      .scrolling-content::-webkit-scrollbar-thumb {
        background-color: #4b5563; /* Gray-600 */
        border-radius: 4px;
      }
      .scrolling-content::-webkit-scrollbar-track {
        background: #374151; /* Gray-700 */
      }

      /* 用于定位居中线 */
      #center-line {
        position: absolute;
        top: 50%;
        left: 0;
        right: 0;
        border-top: 2px dashed #fcd34d; /* Amber-300 */
        z-index: 10;
      }
      /* 内容容器，允许内部内容垂直居中定位 */
      #script-content-wrapper {
        width: 100%;
        max-width: 900px;
        height: 100%;
        overflow-y: scroll;
        scroll-behavior: smooth;
        padding-top: 50vh; /* 确保第一行内容可以滚动到中间 */
        padding-bottom: 50vh; /* 确保最后一行内容可以滚动到中间 */
        /* 初始水平边距将在JS中设置 */
        transition: transform 0.3s ease-out; /* 平滑过渡镜像效果 */
      }
      /* 脚本段落样式 - 现在用于每一行 */
      .script-segment {
        transition: color 0.3s, transform 0.3s, opacity 0.3s;
        text-align: center;
      }
      /* 激活段落/行样式 */
      .active-segment {
        color: #fcd34d !important; /* Amber-300 */
        transform: scale(1.05);
        font-weight: 700 !important;
      }
      /* 识别提示样式 */
      .recognition-hint {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 50;
        padding: 0.5rem 1rem;
        background: rgba(251, 191, 36, 0.95); /* Amber-400 */
        color: #1f2937;
        border-radius: 9999px;
        font-weight: 600;
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.2);
        opacity: 0;
        transition: opacity 0.5s ease;
      }
      .recognition-hint.visible {
        opacity: 1;
      }
    </style>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              primary: "#fcd34d",
              secondary: "#374151",
            },
          },
        },
      };
    </script>
  </head>
  <body class="bg-gray-900 text-gray-100 min-h-screen">
    <div class="container mx-auto p-4 max-w-7xl">
      <!-- NEW: 标题包裹层，用于全屏时隐藏 -->
      <div id="header-wrapper">
        <h1 class="text-3xl font-bold text-center mb-6 text-primary">
          AI智能提词器 🎙️
        </h1>
      </div>

      <!-- 提词器显示区 -->
      <div
        id="teleprompter-display"
        class="relative bg-gray-900 rounded-xl shadow-2xl border border-gray-700"
      >
        <div id="center-line"></div>
        <div id="script-content-wrapper" class="text-gray-300">
          <!-- 脚本内容将在此处插入 -->
        </div>
        <div id="recognition-hint" class="recognition-hint">
          正在听... 请说当前段落
        </div>

        <!-- NEW: 全屏模式下的中心控制图标 (Play/Pause) -->
        <div
          id="fs-overlay-controls"
          class="hidden absolute inset-0 z-50 justify-center items-center pointer-events-none"
        >
          <div
            class="p-4 rounded-full bg-gray-900/60 text-white shadow-2xl transition-opacity duration-300"
          >
            <!-- Pause Icon (Default: Visible when scrolling) -->
            <svg
              id="fs-pause-icon"
              class="w-16 h-16 sm:w-20 sm:h-20"
              fill="currentColor"
              viewBox="0 0 24 24"
            >
              <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z" />
            </svg>
            <!-- Play Icon (Default: Hidden when scrolling) -->
            <svg
              id="fs-play-icon"
              class="w-16 h-16 sm:w-20 sm:h-20 hidden"
              fill="currentColor"
              viewBox="0 0 24 24"
            >
              <path d="M8 5v14l11-7z" />
            </svg>
          </div>
        </div>

        <!-- NEW: 推出全屏按钮 (固定在右上角) -->
        <button
          id="exit-fs-btn"
          class="hidden absolute top-4 right-4 z-50 p-2 rounded-full bg-gray-700/70 text-white hover:bg-gray-600/90 transition-opacity pointer-events-auto shadow-lg"
        >
          <!-- X Icon -->
          <svg
            class="w-6 h-6"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M6 18L18 6M6 6l12 12"
            ></path>
          </svg>
        </button>
      </div>

      <!-- NEW: 底部控制和状态信息包裹层，用于全屏时隐藏 -->
      <div id="bottom-controls-wrapper">
        <!-- 状态和提示信息 -->
        <div
          id="status-message"
          class="text-center mt-4 p-2 rounded-lg font-medium text-red-400"
        >
          <!-- 状态/错误信息 -->
        </div>

        <!-- 控制面板 -->
        <div
          id="control-panel"
          class="bg-gray-800 p-4 rounded-xl mt-6 shadow-lg"
        >
          <div class="flex flex-wrap justify-between items-center gap-4 mb-4">
            <!-- 模式切换按钮 -->
            <button
              id="mode-toggle-btn"
              class="flex-1 min-w-[120px] px-4 py-2 rounded-lg font-semibold transition duration-200 bg-yellow-600 hover:bg-yellow-500 text-gray-900 shadow-md"
            >
              切换到 语音模式
            </button>

            <!-- NEW: 全屏按钮 -->
            <button
              id="fullscreen-btn"
              class="flex-1 min-w-[120px] px-4 py-2 rounded-lg font-semibold transition duration-200 bg-blue-600 hover:bg-blue-500 text-white shadow-md"
            >
              全屏显示
            </button>

            <!-- NEW: 镜像功能按钮 -->
            <button
              id="mirror-toggle-btn"
              class="flex-1 min-w-[120px] px-4 py-2 rounded-lg font-semibold transition duration-200 bg-gray-600 hover:bg-gray-500 text-white shadow-md"
            >
              开启镜像
            </button>

            <!-- 启动/停止按钮 -->
            <button
              id="start-stop-btn"
              class="flex-1 min-w-[120px] px-4 py-2 rounded-lg font-semibold transition duration-200 bg-green-600 hover:bg-green-500 text-white shadow-md"
              disabled
            >
              启动滚动
            </button>

            <!-- 重置按钮 -->
            <button
              id="reset-btn"
              class="flex-1 min-w-[120px] px-4 py-2 rounded-lg font-semibold transition duration-200 bg-red-600 hover:bg-red-500 text-white shadow-md"
            >
              重置位置
            </button>
          </div>

          <!-- Control Row 1: 滚动速度、字体大小、文本边距、段落间距控制 -->
          <div class="flex flex-wrap justify-start items-center gap-6 mt-4">
            <!-- 滚动速度控制 -->
            <div class="w-full sm:w-1/2 lg:w-[23%]">
              <label
                for="scroll-speed"
                class="block text-sm font-medium text-gray-300"
                >滚动速度 (<span id="speed-value">2</span>)</label
              >
              <input
                type="range"
                id="scroll-speed"
                min="0.5"
                max="5"
                step="0.5"
                value="2"
                class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer"
              />
            </div>

            <!-- 字体大小控制 -->
            <div class="w-full sm:w-1/2 lg:w-[23%]">
              <label
                for="font-size"
                class="block text-sm font-medium text-gray-300"
                >字体大小 (<span id="font-value">48px</span>)</label
              >
              <input
                type="range"
                id="font-size"
                min="20"
                max="96"
                step="4"
                value="48"
                class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer"
              />
            </div>

            <!-- 文本边距控制 (Horizontal Padding) -->
            <div class="w-full sm:w-1/2 lg:w-[23%]">
              <label
                for="text-padding"
                class="block text-sm font-medium text-gray-300"
                >文本边距(左右) (<span id="padding-value">20px</span>)</label
              >
              <input
                type="range"
                id="text-padding"
                min="0"
                max="150"
                step="5"
                value="20"
                class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer"
              />
            </div>

            <!-- 段落间距控制 (Vertical Margin) -->
            <div class="w-full sm:w-1/2 lg:w-[23%]">
              <label
                for="paragraph-spacing"
                class="block text-sm font-medium text-gray-300"
                >段落间距(垂直) (<span id="paragraph-value">20px</span>)</label
              >
              <input
                type="range"
                id="paragraph-spacing"
                min="5"
                max="100"
                step="5"
                value="20"
                class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer"
              />
            </div>
          </div>

          <!-- Control Row 2: 行高控制 -->
          <div
            class="flex flex-wrap justify-start items-center gap-6 mt-6 pt-4 border-t border-gray-700"
          >
            <!-- 行高控制 (Line Height) -->
            <div class="w-full sm:w-1/2 lg:w-[23%]">
              <label
                for="line-height-control"
                class="block text-sm font-medium text-gray-300"
                >行高 (行内间距) (<span id="line-height-value">1.5</span
                >)</label
              >
              <input
                type="range"
                id="line-height-control"
                min="1.0"
                max="2.5"
                step="0.1"
                value="1.5"
                class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer"
              />
            </div>
          </div>

          <!-- 文本输入区, 独立一行 -->
          <div class="w-full mt-6">
            <label
              for="script-input"
              class="block text-sm font-medium text-gray-300"
              >演讲稿内容 (请按换行键分隔行)</label
            >
            <!-- 适配横屏和桌面：默认高 6rem (h-24)，中等屏幕以上高 9rem (md:h-36) -->
            <textarea
              id="script-input"
              class="w-full h-24 md:h-36 p-2 mt-1 rounded-lg bg-gray-700 text-gray-200 focus:ring-primary focus:border-primary border border-gray-600"
            >
各位观众大家好，欢迎来到今天的分享会。

信息时代，我们常被数字世界的混乱所困扰。
你是不是也常被电脑、手机、网盘里的文件搞得焦头烂额？
明明保存过的东西，偏偏急用时翻遍全网都找不到？

别急，今天我要给你分享一个超简单的方法——PARA！
只需要4个文件夹，就能让你的数字生活瞬间变清爽，找东西再也不抓狂。

项目（Projects）放你眼下正在忙的事。
领域（Areas）放你生活中需要持续关注的大块领域。
资源（Resources）放你感兴趣或正在学习的知识库。
归档（Archives）放过去完成或暂时用不上的东西。

对，就是这么简单！这四个文件夹，涵盖了你数字生活的所有东西。
工作任务、个人兴趣，PARA都能帮你分得清清楚楚。
我自己试了以后，真的有种“救命啊终于找到组织神器”的感觉！
试一次，你就知道有多爽！
感谢大家的收听，期待与你下期再见！peace～
                    </textarea
            >
          </div>
        </div>
      </div>
      <!-- END OF BOTTOM WRAPPER -->
    </div>

    <script>
      // 全局变量
      let scrollAnimFrameId = null; // NEW: 替换 scrollInterval
      let isScrolling = false;
      let isVoiceMode = false;
      let isMirrored = false;
      let isFullscreen = false;
      let recognition = null;
      let scriptSegments = []; // 现在存储的是每一行
      let currentSegmentIndex = 0; // 现在代表当前行索引

      // DOM 元素
      const headerWrapper = document.getElementById("header-wrapper");
      const bottomControlsWrapper = document.getElementById(
        "bottom-controls-wrapper"
      );
      const display = document.getElementById("script-content-wrapper");
      const input = document.getElementById("script-input");
      const startStopBtn = document.getElementById("start-stop-btn");
      const resetBtn = document.getElementById("reset-btn");
      const speedInput = document.getElementById("scroll-speed");
      const speedValue = document.getElementById("speed-value");
      const fontInput = document.getElementById("font-size");
      const fontValue = document.getElementById("font-value");
      const paddingInput = document.getElementById("text-padding");
      const paddingValue = document.getElementById("padding-value");
      const paragraphInput = document.getElementById("paragraph-spacing");
      const paragraphValue = document.getElementById("paragraph-value");
      const lineHeightInput = document.getElementById("line-height-control");
      const lineHeightValue = document.getElementById("line-height-value");
      const mirrorToggleBtn = document.getElementById("mirror-toggle-btn");
      const fullscreenBtn = document.getElementById("fullscreen-btn");
      const fsOverlayControls = document.getElementById("fs-overlay-controls");
      const fsPauseIcon = document.getElementById("fs-pause-icon");
      const fsPlayIcon = document.getElementById("fs-play-icon");
      const exitFsBtn = document.getElementById("exit-fs-btn");

      const statusMessage = document.getElementById("status-message");
      const modeToggleBtn = document.getElementById("mode-toggle-btn");
      const recognitionHint = document.getElementById("recognition-hint");

      // --- 辅助函数 ---

      /**
       * 渲染脚本到提词器显示区 (现在是按行分割)
       */
      function renderScript() {
        const lines = input.value.split("\n");
        scriptSegments = lines;

        display.innerHTML = "";
        const currentParagraphSpacing = paragraphInput.value;
        const currentLineHeight = lineHeightInput.value;
        const lineVPadding = "8px"; // 垂直内边距，使高亮效果更明显

        scriptSegments.forEach((segment, index) => {
          const div = document.createElement("div");
          // 如果是空行，用 &nbsp; 保持空间，并用作段落分隔
          const content = segment.trim() === "" ? "&nbsp;" : segment.trim();

          div.className =
            "script-segment text-2xl md:text-3xl lg:text-4xl font-semibold opacity-70 transition-all duration-300";
          div.id = `segment-${index}`;
          div.innerHTML = content;
          div.style.fontSize = `${fontInput.value}px`;
          div.style.lineHeight = currentLineHeight;

          if (segment.trim() === "") {
            // 这是段落间的空行
            div.style.marginBottom = `${currentParagraphSpacing}px`;
            div.style.height = "0"; // 确保空行本身不占据多余的高度
            div.style.padding = "0";
          } else {
            // 这是内容行
            div.style.paddingTop = lineVPadding;
            div.style.paddingBottom = lineVPadding;
            div.style.marginBottom = "0px";
          }

          // 如果当前处于镜像状态，新渲染的行也要翻转回来
          if (isMirrored) {
            div.style.transform = "scaleX(-1)";
          }

          display.appendChild(div);
        });

        // 首次渲染后，重置并激活第一个段落
        resetPosition();
        updateActiveSegment();

        // 只有所有行都为空时才禁用启动按钮
        updateStartButtonState();
      }

      /**
       * 检查内容是否可滚动并更新启动按钮状态
       */
      function updateStartButtonState() {
        const hasContent =
          scriptSegments.length > 0 &&
          scriptSegments.some((s) => s.trim() !== "");

        if (!hasContent) {
          startStopBtn.disabled = true;
          return;
        }

        // 延迟检查，确保DOM布局完成且scrollHeight计算准确
        setTimeout(() => {
          // 检查内容是否溢出容器
          const isScrollable = display.scrollHeight > display.clientHeight;
          startStopBtn.disabled = !isScrollable;

          if (!isScrollable && !isVoiceMode) {
            statusMessage.innerText =
              "⚠️ 脚本内容太短，无法启动滚动。请添加更多文本。";
          } else {
            statusMessage.innerText = "";
          }
        }, 50); // 50ms 延迟确保布局完成
      }

      /**
       * 更新当前活动的段落/行样式
       */
      function updateActiveSegment() {
        document.querySelectorAll(".script-segment").forEach((el, index) => {
          el.classList.remove("active-segment", "opacity-100");

          if (index === currentSegmentIndex) {
            el.classList.add("active-segment", "opacity-100");
            el.classList.remove("opacity-70", "opacity-30");
          } else if (index < currentSegmentIndex) {
            // 已读过的行变淡
            el.classList.add("opacity-30");
            el.classList.remove("opacity-70");
          } else {
            // 未读过的行保持中等亮度
            el.classList.add("opacity-70");
            el.classList.remove("opacity-30");
          }
        });
      }

      /**
       * 根据当前滚动位置更新活动段落
       */
      function updateSegmentByScrollPosition() {
        // 如果在自动滚动或语音模式下，则不通过滚动位置来更新活动段落，以免冲突
        if (isScrolling || isVoiceMode) return;

        const segments = document.querySelectorAll(".script-segment");
        if (segments.length === 0) return;

        const displayRect = document
          .getElementById("teleprompter-display")
          .getBoundingClientRect();
        // 目标位置：提词器显示区垂直中点的绝对位置
        const centerOffset = displayRect.top + displayRect.height / 2;

        let bestIndex = currentSegmentIndex; // 默认值
        let minDistance = Infinity;

        segments.forEach((el, index) => {
          // 忽略空行（段落分隔符）的匹配
          if (scriptSegments[index].trim() === "") return;

          const rect = el.getBoundingClientRect();
          // 段落中心点相对于屏幕顶部的绝对位置
          const elCenter = rect.top + rect.height / 2;

          // 段落中心点与提词器中线的距离
          const distance = Math.abs(elCenter - centerOffset);

          if (distance < minDistance) {
            minDistance = distance;
            bestIndex = index;
          }
        });

        if (bestIndex !== currentSegmentIndex) {
          currentSegmentIndex = bestIndex;
          updateActiveSegment();
        }
      }

      /**
       * 平滑滚动到当前活动段落的中央
       */
      function smoothScrollToActiveSegment() {
        const activeSegment = document.getElementById(
          `segment-${currentSegmentIndex}`
        );
        if (activeSegment) {
          // 使用 scrollIntoView 居中对齐
          activeSegment.scrollIntoView({
            behavior: "smooth",
            block: "center",
          });
        }
      }

      /**
       * 检查 Web Speech API 兼容性
       */
      function checkSpeechApi() {
        if (
          !("webkitSpeechRecognition" in window) &&
          !("SpeechRecognition" in window)
        ) {
          statusMessage.innerText =
            "⚠️ 警告: 您的浏览器不支持 Web Speech API (语音识别)。智能语音模式将不可用。";
          modeToggleBtn.disabled = true;
          return false;
        }
        statusMessage.innerText = "";
        return true;
      }

      /**
       * 更新全屏模式下的暂停/播放图标
       */
      function updateFullscreenIcons() {
        if (!isFullscreen) return;
        if (isScrolling) {
          fsPauseIcon.classList.remove("hidden");
          fsPlayIcon.classList.add("hidden");
        } else {
          fsPauseIcon.classList.add("hidden");
          fsPlayIcon.classList.remove("hidden");
        }
      }

      // --- 核心模式逻辑：手动滚动 (使用 requestAnimationFrame) ---

      /**
       * 滚动循环 (使用 requestAnimationFrame)
       */
      function scrollLoop() {
        if (!isScrolling) return;

        const speed = parseFloat(speedInput.value);

        // 检查是否到达底部，留出5px的缓冲
        if (
          display.scrollTop + display.clientHeight >=
          display.scrollHeight - 5
        ) {
          stopScroll();
          return;
        }

        // 应用滚动
        display.scrollTop += speed;

        // 继续下一帧的循环
        scrollAnimFrameId = requestAnimationFrame(scrollLoop);
      }

      function startScroll() {
        if (isScrolling) return;

        // 1. 确保内容可滚动
        if (display.scrollHeight <= display.clientHeight) {
          statusMessage.innerText =
            "⚠️ 脚本内容太短，无需滚动。请添加更多文本。";
          console.warn(
            "Cannot start scroll: ScrollHeight is not greater than ClientHeight."
          );
          stopScroll(); // 确保按钮状态是停止
          return;
        }

        isScrolling = true;
        startStopBtn.innerText = "暂停滚动";
        startStopBtn.classList.remove("bg-green-600", "hover:bg-green-500");
        startStopBtn.classList.add("bg-orange-600", "hover:bg-orange-500");

        updateFullscreenIcons();

        // 2. 启动 requestAnimationFrame 循环
        scrollLoop();
      }

      function stopScroll() {
        if (!isScrolling) return;
        isScrolling = false;

        // 使用 cancelAnimationFrame 停止循环
        if (scrollAnimFrameId) {
          cancelAnimationFrame(scrollAnimFrameId);
          scrollAnimFrameId = null;
        }

        startStopBtn.innerText = "启动滚动";
        startStopBtn.classList.remove("bg-orange-600", "hover:bg-orange-500");
        startStopBtn.classList.add("bg-green-600", "hover:bg-green-500");

        updateFullscreenIcons();
      }

      // --- 核心模式逻辑：语音智能推进 ---

      function initSpeechRecognition() {
        if (!checkSpeechApi()) return;

        const SpeechRecognition =
          window.SpeechRecognition || window.webkitSpeechRecognition;
        recognition = new SpeechRecognition();
        recognition.continuous = false; // 只听一句
        recognition.interimResults = false; // 只返回最终结果
        recognition.lang = "zh-CN"; // 设置中文识别

        recognition.onstart = () => {
          recognitionHint.innerText = "🎙️ 正在听... 请说当前行";
          recognitionHint.classList.add("visible");
          statusMessage.innerText = "语音模式已启动，请开始朗读。";
        };

        recognition.onresult = (event) => {
          const transcript = event.results[0][0].transcript;
          console.log("识别结果:", transcript);
          checkAndAdvance(transcript);
        };

        recognition.onend = () => {
          recognitionHint.classList.remove("visible");
          if (isVoiceMode) {
            // 如果未完成，自动重新启动监听
            setTimeout(() => {
              if (isVoiceMode && currentSegmentIndex < scriptSegments.length) {
                try {
                  recognition.start();
                } catch (e) {
                  console.warn(
                    "Recognition already started, ignoring auto-restart."
                  );
                }
              } else if (currentSegmentIndex >= scriptSegments.length) {
                statusMessage.innerText = "✅ 脚本朗读完毕！";
              }
            }, 100);
          }
        };

        recognition.onerror = (event) => {
          console.error("语音识别错误:", event.error);
          statusMessage.innerText = `❌ 语音识别错误: ${event.error}. 请检查麦克风权限。`;
          recognitionHint.classList.remove("visible");
          if (isVoiceMode) {
            // 错误后尝试重新启动
            setTimeout(() => {
              if (isVoiceMode && currentSegmentIndex < scriptSegments.length) {
                try {
                  recognition.start();
                } catch (e) {}
              }
            }, 1000);
          }
        };
      }

      function startVoiceControl() {
        if (!recognition) initSpeechRecognition();
        isVoiceMode = true;
        startStopBtn.disabled = true; // 语音模式下禁用手动启动按钮
        speedInput.disabled = true;
        fullscreenBtn.disabled = true;

        modeToggleBtn.innerText = "切换到 手动模式";
        modeToggleBtn.classList.remove("bg-yellow-600", "hover:bg-yellow-500");
        modeToggleBtn.classList.add("bg-purple-600", "hover:bg-purple-500");

        stopScroll(); // 确保手动滚动已停止

        // 确保当前行是居中且可读的
        smoothScrollToActiveSegment();

        if (currentSegmentIndex < scriptSegments.length) {
          recognition.start();
        } else {
          statusMessage.innerText = "请点击重置按钮开始朗读。";
        }
      }

      function stopVoiceControl() {
        isVoiceMode = false;
        // 只有所有行都为空时才禁用启动按钮
        updateStartButtonState(); // 使用新的检查函数
        speedInput.disabled = false;
        fullscreenBtn.disabled = false;

        modeToggleBtn.innerText = "切换到 语音模式";
        modeToggleBtn.classList.remove("bg-purple-600", "hover:bg-purple-500");
        modeToggleBtn.classList.add("bg-yellow-600", "hover:bg-yellow-500");

        recognitionHint.classList.remove("visible");
        statusMessage.innerText = "已切换回手动模式。";

        if (recognition) {
          recognition.stop();
        }
      }

      /**
       * 检查识别结果并推进到下一个行
       * @param {string} transcript 识别的文本
       */
      function checkAndAdvance(transcript) {
        if (!isVoiceMode || currentSegmentIndex >= scriptSegments.length)
          return;

        // 1. 跳过所有空行
        while (
          currentSegmentIndex < scriptSegments.length &&
          scriptSegments[currentSegmentIndex].trim() === ""
        ) {
          currentSegmentIndex++;
        }
        if (currentSegmentIndex >= scriptSegments.length) {
          stopVoiceControl();
          statusMessage.innerText = "✅ 脚本朗读完毕！切换回手动模式。";
          return;
        }

        const currentLine = scriptSegments[currentSegmentIndex];
        // 尝试匹配当前行开头的较小片段 (8-15个字符)
        const matchText = currentLine
          .replace(/[，。！？]/g, "")
          .trim()
          .slice(0, 15);

        // 匹配逻辑：如果识别结果包含了当前行大部分文本或关键开头
        // 判断标准: 1. 识别文本包含目标行开头8个字符
        // OR 2. 识别文本长度达到目标文本长度的一半 AND 识别文本包含目标文本开头3个字符
        const isMatch =
          transcript.includes(matchText.slice(0, 0)) ||
          (transcript.length > matchText.length * 0.5 &&
            transcript.includes(matchText.slice(0, 3)));

        if (isMatch) {
          console.log(
            `Matched line ${currentSegmentIndex + 1}: "${currentLine.slice(
              0,
              10
            )}..."`
          );
          currentSegmentIndex++;
          updateActiveSegment();
          smoothScrollToActiveSegment(); // 滚动到下一行

          if (currentSegmentIndex < scriptSegments.length) {
            // 继续监听下一个行
            setTimeout(() => {
              if (isVoiceMode) recognition.start();
            }, 500);
          } else {
            // 脚本朗读完毕
            stopVoiceControl();
            statusMessage.innerText = "✅ 脚本朗读完毕！切换回手动模式。";
          }
        } else {
          // 未匹配，继续监听
          setTimeout(() => {
            if (isVoiceMode) recognition.start();
          }, 500);
        }
      }

      /**
       * 切换镜像状态
       */
      function toggleMirroring() {
        isMirrored = !isMirrored;
        const segments = document.querySelectorAll(".script-segment");

        if (isMirrored) {
          // 1. 翻转内容容器 (Wrapper)
          display.style.transform = "scaleX(-1)";
          // 2. 翻转内部文本 (Segments) 使其可读
          segments.forEach((el) => {
            el.style.transform = "scaleX(-1)";
          });
          mirrorToggleBtn.innerText = "关闭镜像";
          mirrorToggleBtn.classList.remove("bg-gray-600", "hover:bg-gray-500");
          mirrorToggleBtn.classList.add("bg-blue-600", "hover:bg-blue-500");
        } else {
          // 1. 恢复内容容器
          display.style.transform = "none";
          // 2. 恢复内部文本
          segments.forEach((el) => {
            el.style.transform = "none";
          });
          mirrorToggleBtn.innerText = "开启镜像";
          mirrorToggleBtn.classList.remove("bg-blue-600", "hover:bg-blue-500");
          mirrorToggleBtn.classList.add("bg-gray-600", "hover:bg-gray-500");
        }
      }

      /**
       * 切换全屏状态
       */
      function toggleFullscreen() {
        isFullscreen = !isFullscreen;

        if (isFullscreen) {
          // 禁用语音模式，防止冲突
          if (isVoiceMode) stopVoiceControl();

          // 隐藏所有非显示区元素
          document.body.classList.add("overflow-hidden");
          headerWrapper.classList.add("hidden");
          bottomControlsWrapper.classList.add("hidden");

          // 提词器显示区进入全屏
          document
            .getElementById("teleprompter-display")
            .classList.add("is-fullscreen");

          // 显示全屏控制层和退出按钮
          fsOverlayControls.classList.remove("hidden");
          fsOverlayControls.classList.add("flex");
          exitFsBtn.classList.remove("hidden"); // 显示退出按钮

          // 切换按钮文字
          fullscreenBtn.innerText = "退出全屏";

          // 更新全屏图标状态
          updateFullscreenIcons();

          // 确保在全屏状态下，按钮状态基于内容长度
          updateStartButtonState();
        } else {
          // 退出全屏
          document.body.classList.remove("overflow-hidden");
          headerWrapper.classList.remove("hidden");
          bottomControlsWrapper.classList.remove("hidden");

          document
            .getElementById("teleprompter-display")
            .classList.remove("is-fullscreen");

          // 隐藏全屏控制层和退出按钮
          fsOverlayControls.classList.add("hidden");
          fsOverlayControls.classList.remove("flex");
          exitFsBtn.classList.add("hidden"); // 隐藏退出按钮

          // 切换按钮文字
          fullscreenBtn.innerText = "全屏显示";

          // 退出全屏时停止滚动
          stopScroll();
          updateStartButtonState(); // 退出全屏后更新按钮状态
        }
      }

      /**
       * 全屏模式下的点击事件处理 (暂停/播放)
       */
      function handleFullscreenClick() {
        if (isFullscreen && !isVoiceMode) {
          if (isScrolling) {
            stopScroll();
          } else {
            if (!startStopBtn.disabled) {
              startScroll();
            }
          }
        }
      }

      // --- 事件监听 ---

      // 模式切换
      modeToggleBtn.addEventListener("click", () => {
        if (isVoiceMode) {
          stopVoiceControl();
        } else {
          // 语音模式与全屏滚动互斥
          if (isFullscreen) {
            statusMessage.innerText = "⚠️ 请先退出全屏，再切换到语音模式。";
            return;
          }
          startVoiceControl();
        }
      });

      // 手动启动/停止
      startStopBtn.addEventListener("click", () => {
        if (isVoiceMode) return;
        isScrolling ? stopScroll() : startScroll();
      });

      // 镜像切换
      mirrorToggleBtn.addEventListener("click", toggleMirroring);

      // 全屏切换 (控制面板按钮)
      fullscreenBtn.addEventListener("click", () => {
        if (isVoiceMode) {
          statusMessage.innerText =
            "⚠️ 语音模式下无法进入全屏滚动模式。请先切换到手动模式。";
          return;
        }
        toggleFullscreen();
      });

      // NEW: 退出全屏按钮 (固定在右上角的按钮)
      exitFsBtn.addEventListener("click", toggleFullscreen);

      // 全屏模式下点击提词器区域实现暂停/播放
      document
        .getElementById("teleprompter-display")
        .addEventListener("click", handleFullscreenClick);

      // 监听 Esc 键退出全屏
      document.addEventListener("keydown", (e) => {
        if (isFullscreen && e.key === "Escape") {
          toggleFullscreen();
        }
      });

      // 监听提词器区域的滚动事件，实时更新活动段落（用户手动操作时）
      display.addEventListener("scroll", updateSegmentByScrollPosition);

      // 监听键盘事件，用于蓝牙遥控器控制
      document.addEventListener("keydown", (e) => {
        // 确保输入框没有聚焦，防止输入文字时触发控制
        if (input === document.activeElement) return;

        // 蓝牙遥控器通常模拟 Space, Enter, 或 Arrow Keys

        // 1. 全局播放/暂停 (Spacebar 或 Enter/Return)
        if (e.code === "Space" || e.key === "Enter") {
          e.preventDefault();
          if (isVoiceMode) return; // 语音模式不响应

          if (isFullscreen && !startStopBtn.disabled) {
            handleFullscreenClick();
          } else if (!isFullscreen && !startStopBtn.disabled) {
            isScrolling ? stopScroll() : startScroll();
          }
        }

        // 2. 微调滚动 (Arrow Up/Down) - 仅在手动模式下进行
        if (!isVoiceMode) {
          const scrollStep = 40; // 每次调整40像素
          let scrolled = false;

          if (e.key === "ArrowDown") {
            e.preventDefault();
            // 只有在非自动滚动时才允许微调
            if (!isScrolling) {
              display.scrollTop += scrollStep;
              scrolled = true;
            }
          } else if (e.key === "ArrowUp") {
            e.preventDefault();
            if (!isScrolling) {
              display.scrollTop -= scrollStep;
              scrolled = true;
            }
          }

          // 如果进行了微调，手动触发活动段落更新
          if (scrolled) {
            // 延迟调用，确保滚动完成后段落位置计算准确
            setTimeout(updateSegmentByScrollPosition, 100);
          }
        }
      });

      // 重置按钮
      resetBtn.addEventListener("click", () => {
        stopScroll();
        if (isVoiceMode) stopVoiceControl();
        resetPosition();
      });

      function resetPosition() {
        currentSegmentIndex = 0;
        display.scrollTop = 0; // 滚动到顶部，让第一个段落可见
        updateActiveSegment();
        if (isVoiceMode && scriptSegments.length > 0) {
          startVoiceControl(); // 如果在语音模式下重置，则重新启动监听
        }
      }

      // 输入框内容变化时重新渲染脚本
      input.addEventListener("input", () => {
        renderScript();
        stopScroll(); // 确保修改脚本时停止滚动
        if (isVoiceMode) stopVoiceControl(); // 确保修改脚本时停止语音模式
      });

      // 速度变化
      speedInput.addEventListener("input", () => {
        speedValue.innerText = speedInput.value;
        // 使用 rAF 后，速度变化无需停止/重启，直接在 scrollLoop 中生效
        // 但如果当前没有滚动，需要确保下次启动时的速度是新的
      });

      // 字体变化
      fontInput.addEventListener("input", () => {
        fontValue.innerText = `${fontInput.value}px`;
        document.querySelectorAll(".script-segment").forEach((el) => {
          el.style.fontSize = `${fontInput.value}px`;
          // 确保字体大小变化后，镜像样式保持
          if (isMirrored) el.style.transform = "scaleX(-1)";
        });
        updateSegmentByScrollPosition(); // 字体大小变化可能影响当前行位置
      });

      // 文本边距变化 (Horizontal Padding)
      paddingInput.addEventListener("input", () => {
        const value = `${paddingInput.value}px`;
        paddingValue.innerText = value;
        // 应用 padding 到内容 wrapper
        display.style.paddingLeft = value;
        display.style.paddingRight = value;
        updateSegmentByScrollPosition();
      });

      // 段落间距变化 (Vertical Margin)
      paragraphInput.addEventListener("input", () => {
        const value = `${paragraphInput.value}px`;
        paragraphValue.innerText = value;
        // 应用 margin-bottom 到所有脚本段落
        document.querySelectorAll(".script-segment").forEach((el, index) => {
          // 只有空行才应用段落间距
          if (scriptSegments[index].trim() === "") {
            el.style.marginBottom = value;
          }
        });
        updateSegmentByScrollPosition();
      });

      // 行高变化 (Line Height)
      lineHeightInput.addEventListener("input", () => {
        const value = lineHeightInput.value;
        lineHeightValue.innerText = value;
        // 应用 line-height 到所有脚本段落
        document.querySelectorAll(".script-segment").forEach((el) => {
          el.style.lineHeight = value;
        });
        updateSegmentByScrollPosition();
      });

      // 监听窗口大小变化（特别是针对移动端旋转和地址栏显示/隐藏）
      window.addEventListener("resize", () => {
        // 延迟检查，确保DOM尺寸稳定
        setTimeout(updateStartButtonState, 200);
        // 如果正在滚动，停止并重新检查滚动状态，因为窗口变化会影响滚动边界
        if (isScrolling) {
          stopScroll();
        }
        // 确保活动行保持在中心
        smoothScrollToActiveSegment();
      });

      // --- 初始化 ---

      window.onload = function () {
        // 1. 初始化脚本
        renderScript();

        // 2. 检查语音API
        checkSpeechApi();

        // 3. 初始化语音识别对象 (但暂时不启动)
        initSpeechRecognition();

        // 4. 初始化UI状态 (使用新的检查，它会延迟执行)
        updateStartButtonState();

        // 5. 应用初始文本边距
        display.style.paddingLeft = `${paddingInput.value}px`;
        display.style.paddingRight = `${paddingInput.value}px`;

        // 6. 初始定位
        resetPosition();
      };
    </script>
  </body>
</html>
